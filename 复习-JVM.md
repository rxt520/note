# 复习-JVM

## 类的加载

类的加载其实本质就是将.class类加载进内存中，将其放在方法区中，然后再堆中创建一个`java.lang.Class`对象，用来封装方法区内类的数据结构信息，并提供了访问方法区中数据结构的接口。

### 类的生命周期

#### 加载

根据类的全限定名，通过类加载器(`boostrapClassLoader`,`ExtClassLoader`,`AppClassLoader`，`自定义ClassLoader`)，把变成二进制的.class文件放进方法区中，并生成`java.lang.Class` 进堆中，`Class`对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。

##### 类加载机制

​	缓存，类进行加载之后，会进行缓存。

​	双亲委派，先让父类进行加载，如果父类加载不了，再让子类进行加载

​	全盘负责，如果该加载器负责加载一个类，则这个类的引用和依赖都由此类，进行加载

#### 连接

##### 验证

确保被加载的类的正确性，是否有语法错误等

##### 准备

为类的静态变量分配内存，并将其初始化为默认值(一般在这里初始化为零值 null,0,0L,false )

##### 解析

把类中的符号引用转换为直接引用： 类中的引用可能只是一个符号，并不是一个地址，所以要进行转换

#### 初始化

初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。

- 1、假如这个类还没有被加载和连接，则程序先加载并连接该类
- 2、假如该类的直接父类还没有被初始化，则先初始化其直接父类
- 3、假如类中有初始化语句，则系统依次执行这些初始化语句

#### 卸载

在如下几种情况下，Java虚拟机将结束生命周期

- 执行了 `System.exit()`方法
- 程序正常执行结束
- 程序在执行过程中遇到了异常或错误而异常终止
- 由于操作系统出现错误而导致Java虚拟机进程终止





### JVM的内存模型

#### 线程共享

方法区： 存储常量，静态变量，类的元数据信息

堆： 存储实例化对象 ， 是垃圾回收的主要区域，分为 年轻代，老年嗲

年轻代还分为 Eden ， survivor1 ，survivor2 

#### 线程私有

虚拟机栈： 存储栈帧，栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。**每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。**

本地方法栈：和虚拟机栈类似，但是是使用其他编程语言

程序计数器：存储方法执行到哪一行，下一个行执行什么指令



### 垃圾收集算法

1. 引用计数法

   有引用，这个类的计数 就 +1 ，用完了就 -1 ，当为0的时候，就可以清理了，但是会出现相互依赖的情况，就没有办法清理了

2. 复制算法

   将原本分配的内存区域分成两份，然后其中一份没有数据，当发生回收的时候，将存活的对象复制到这个区域，原本的区域直接清空，缺点： 浪费较大的空间，适合用在生命周期较短的对象身上

3. 标记清除

   将内存中需要清理的对象进行标记，然后清理。缺点：内存碎片过多，不是连续空闲空间，如果出现大对象不能分配，就只能再次GC

4. 标记整理

   将内存中需要清理的对象进行标记，清理的同时，不会被回收的对象向一端移动。

### 垃圾收集器

#### Serial 

使用单线程复制算法，在新生代使用

#### Serial Old

使用单线程 标记-整理算法，在老年代使用

#### ParNew

Serial 的多线程版本

#### Parallel Scavenge

类似ParNew收集器，Parallel收集器更关注系统的吞吐量。

#### Parallel Old

Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记－整理”算法。

#### CMS

CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。

是一种标记清除算法的优化版本。

#### G1

将内存分为2048 个 region ，每个region 是 1-32M ， 然后划分为eden ， survivor， old ，Humongous（存储大对象，达到0.5region） 区

1. **年轻代GC** ：当对象在eden区耗尽的时候，会触发一次年轻代gc，只会触发 eden  和 survivor 区域的回收，eden 存活对象复制到

survivor 区域，如果survivor 空间不足，会直接复制到old区域，survivor 中的存活对象判断存活年龄是否到达阈值，如果到达

则复制到old区，没到达，继续存活。多个垃圾回收线程并行执行，会触发stw

2. **老年代并发标记**：当堆内存使用达到45% 的时候，就会触发一次老年代并发标记，初始标记堆中根可达的对象，会触发STW ， 和 年轻代GC，根区域扫描 survivor区域可达old区域，并进行标记，并发标记会计算对象存活比例，如果都是垃圾，则直接回收这个区域，再次标记，对以上结果进行修正，是stw的， 老年代并发标记主要是为了混合回收做铺垫
3. **混合回收 **Mixed GC：当老年代对象占比达到设定区域（默认65%），则进行回收，主要回收年轻代和部分老年代，主要使用复制算法，将存活对象复制到空闲区域，如果空间不足，则会进行full gc

​	





