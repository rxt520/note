# 复习-Redis

## 存储结构

redis 使用的是 hashtable，实际上是一个数组 + 链表的形式，

解决hash冲突的办法是 链表法

![image-20221006005935466](C:\Users\Administrator\Desktop\note\typoraImg\image-20221006005935466.png)

### 扩容/缩容

扩容条件： 1)Redis服务器目前没有在执行BGSAVE或BGREWRITEAOF命令，并且哈希表的负载因子大于等于1。

​					2)Redis服务器目前在执行BGSAVE或BGREWRITEAOF命令，并且哈希表的负载因子大于等于5。

缩容的条件：哈希表的负载因子小于0.1。

#### rehash步骤：

将rehashids 置为0 ，表示正在rehash ， 

然后将dictht[0] 里的内容逐渐的转移到dictht[1]中(转移过程中会重新计算hash所处的索引值), 原dictht[0]  释放，最后将dictht[1]设置为dictht[0] ，dictht[1]设置为空的hashtable，然后将rehashids 置位-1

由于数据量过大，所以redis 采用了 ，操作（增删改查）的时候 以及 定时的 转移dictht[0]



## 基本类型

1. String

   底层为redis 自己构建的SDS 动态字符串

2. hash

   1. ziplist
   2. hashtable

3. list

   1. ziplist 为了节省内存redis自己定义的一种结构，由 长度 + 数据，来进行压缩内存，缺点是查询效率变慢
   2. linkedlist

4. set

   1. intset
   2. hashtable

5. zset

   1. ziplist
   2. skiplist

![image-20221006105438424](C:\Users\Administrator\Desktop\note\typoraImg\image-20221006105438424.png)





### 跳表

![image-20221006111552831](C:\Users\Administrator\Desktop\note\typoraImg\image-20221006111552831.png)



跳表就是将链表中抽出一层索引，以供提高查询效率，可以抽出多层。



为什么Redis 使用跳表，而不是使用B+树呢？MySql不用跳表呢？

跳表和B+ 都是可以范围查询的，而且都是高效的算法，但是在查询的时候，是不一样的，

B+ 树，在查询目标索引的时候，需要将 磁盘块加载进内存，然后进行计算出下一个磁盘块的位置，最终查询到目标数据

跳表，查询目标索引位置的时候，需要不断加载的下一个索引的位置，然后插叙难道最终目标的位置，

redis使用跳表的原因：

由于Redis本来就是在内存里面进行存储的，所以不需要经历磁盘IO，也不需要经历B+树的页分裂等问题，所以使用了跳表

Mysql 不使用跳表的原因：

因为跳表会经历多次磁盘IO



为什么redis不使用红黑树？

因为红黑树不能进行范围查找





## 工作原理

单线程模型：

![image-20221005202037509](C:\Users\Administrator\Desktop\note\typoraImg\image-20221005202037509.png)

客户端请求Redis 服务器，生成 socket  fd ， 通过IO 多路复用器，添加到一个队列里面，然后进行单线程处理，先经过事件分发器，然后到对应的事件处理中进行处理，



常用的处理器：   当客户端 连接的时候使用 连接应答处理器

客户端写的时候，使用命令请求处理器

客户端读的时候，使用命令回复处理器



### Redis为什么快

1. 基于内存
2. 单线程，避免了上下文切换，预防了多线程下的锁竞争
3. 瓶颈是网络IO 和 内存，Redis 又将网络IO进行了优化，使用了多路复用
4. 底层优秀的数据结构



## 淘汰策略

内存不足的时候，会使用内存淘汰策略：

noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。默认策略
allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。
allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。
volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。
volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。
volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。
在平时的业务开发中推荐使用allkeys-lru和volatile-lru两种过期策略。

LRU是Least Recently Used的缩写，即最近最少使用。LRU源于操作系统的一种页面置换算法，选择最近最久未使用的页面予以淘汰。在Redis里，就是选择最近最久未使用的key进行删除。





LRU(Least Recently Used)：hash表 + 链表中，如果使用就加到链表头部， 进行内存淘汰的时候，将链表尾部删除 

LFU(Least Frequently Used)：需要两个hash表 + 链表的结构，一个hash表是正常hash表，另外一个hash表存储的是使用频率的Hash表

当key再次被使用的时候，使用频率+1 ， 从使用频率hash表(index = 1)中移除，增加到新的中(index = i + 1)



## 过期策略

Redis是使用定期删除+惰性删除两者配合的过期策略。

#### 定期删除

所谓定期删除，redis是这样子做的。每隔100ms就会随机抽取扫描设置了过期时间的key，判断这些key是不是已经过期了，如果过期了就删除。那为什么不直接删除掉所有过期的key呢？因为key量很大的时候全盘扫描key会很消耗性能，所以还需要配合惰性删除。

#### 惰性删除

所谓惰性删除不再是主动删除。就是客户端请求某个key的时候，redis会去判断key是否失效，如果失效了就删除，没失效就返回给客户端。所以惰性删除可以解决一些过期了，但没被定期删除随机抽取到的key。但有些过期的key既没有被随机抽取，也没有被客户端访问，就会一直保留在数据库，占用内存，长期下去可能会导致内存耗尽。所以可以使用上面提到的内存淘汰机制来解决。



## 持久化

### RDB

RDB是基于快照一次的全量备份，即周期性的把redis当前内存中的全量数据写入到一个快照文件中(周期时间可以通过配置来调整)。

redis 采用多线程处理 持久化的请求。

问题： redis 还在处理写命令的时候，触发了持久化，怎么办？

redis 持久化的时候会 fork 一个子进程，子进程的内存区域和 主进程一致，如果主进程有写操作，这个时候会采用copyOnWrite，复制一份需要处理的内存pagecache(大小4k)出来，只复制需要处理的部分。



RDB： 恢复快



#### AOF



追加指令日志的形式，进行持久化，会把指令交给内核，内核进行日志文件的追加。

redis重启的时候，就通过命令进行恢复，恢复时间长，所以AOF 会进行重写，将日志进行合并

需要fork一个子进程，对旧aof文件进行优化，写进新的aof文件，然后替换掉旧的。

#### AOF + RDB

混合模式，在aof文件中，增加了RDB快照，有新的命令，就继续追加，到一定时间之后，会继续转化为RDB。





## 缓存

为了降低后端服务器的压力，某些数据长时间内是不会改变的，但是又被经常访问到，这时候就可以采用缓存的方式。

### 设置缓存过期时间的目的

1. 节省空间，内存淘汰策略
2. 做到数据弱一致性，有效期失效后，再次访问可以做到数据的一致性



### 缓存穿透

数据库没有数据，但是却一直访问，没有形成缓存

可以使用布隆过滤器进行过滤。

布隆过滤器：可以看作是一个长度为n的数组，然后将key 进行k次hash，对应的下表就为1.

将缓存里的所有key都放进布隆过滤器中，那么当查询数据的时候，如果key不存在于布隆过滤器中，则一定不存在。

可以大大减少数据库的压力。



### 缓存击穿

热点数据缓存有效期过期，然后瞬间大量的请求打进来。导致数据库压力暴增。

1. 设置永不过期
2. 分布式锁，在程序访问缓存的时候，如果缓存不存在，则加锁，查询数据库后加入缓存，解锁。其他的程序在获取到锁后再次判断是否缓存为空，不为空直接解锁，继续执行



### 缓存雪崩

大批量缓存过期，且同时访问，数据库压力骤增

1. 设置永不过期
2. 随机过期时间



## 缓存一致性

建议： 先更新数据库再删除缓存

问题1： 存在缓存刚好过期的时候，

	1. A线程读取数据库   
	1. B 更新数据库
	1. B 删除缓存
	1. A 添加旧数据缓存

概率较小

问题2： 删除缓存失败

可以将删除失败入队列





## 集群

1. 主从模式

   主节点负责处理使用者的IO操作，而从节点则会对主节点的数据进行备份，并且也会对外提供读操作的处理。

   master - slave 模式，读写分离，但是master宕机之后，就无法运转了

2. 哨兵模式

   基于主从模式，多了一个sentinel ， sentinel 可以集群，会监听主节点，如果主节点挂了，会选举从节点成为新的主节点

3. 集群

​		Redis Cluster 把所有的数据划分为16384个不同的槽位，可以根据机器的性能把不同的槽位分配给不同的Redis实例，对于Redis实例来说，他们只会存储部门的Redis数据，当然，槽的数据是可以迁移的，不同的实例之间，可以通过一定的协议，进行数据迁移。





主从复制原理：

异步复制：

全量/增量：

​	slave发送同步数据请求，然后将offset(-1代表全量) 给master ，master 给slave分配一个client buffer，

然后master fork 一个子进程，用来生成RDB文件，然后通过父进程发送给slave，

slave 进行读取，期间产生的写操作，会写入client buffer中，然后同步给slave









## 分布式锁



RedLock：

要实现RedLock，需要至少5个实例（官方推荐），且每个实例都是master，不需要从库和哨兵。

1. **获取当前时间（毫秒数）。**
2. **按顺序依次向N个Redis节点执行获取锁的操作。**这个获取操作跟前面基于单Redis节点的获取锁的过程相同，包含随机字符串my_random_value，也包含过期时间(比如PX 30000，即锁的有效时间)。为了保证在某个Redis节点不可用的时候算法能够继续运行，这个获取锁的操作还有一个超时时间(time out)，它要远小于锁的有效时间（几十毫秒量级）。客户端在向某个Redis节点获取锁失败以后，应该立即尝试下一个Redis节点。这里的失败，应该包含任何类型的失败，比如该Redis节点不可用，或者该Redis节点上的锁已经被其它客户端持有（注：Redlock原文中这里只提到了Redis节点不可用的情况，但也应该包含其它的失败情况）。
3. **计算整个获取锁的过程总共消耗了多长时间，计算方法是用当前时间减去第1步记录的时间**。如果客户端从大多数Redis节点（>= N/2+1）成功获取到了锁，并且获取锁总共消耗的时间没有超过锁的有效时间(lock validity time)，那么这时客户端才认为最终获取锁成功；否则，认为最终获取锁失败。
4. **如果最终获取锁成功了，那么这个锁的有效时间应该重新计算**，它等于最初的锁的有效时间减去第3步计算出来的获取锁消耗的时间。
5. **如果最终获取锁失败了**（可能由于获取到锁的Redis节点个数少于N/2+1，或者整个获取锁的过程消耗的时间超过了锁的最初有效时间），那么客户端应该立即向所有Redis节点发起释放锁的操作（即前面介绍的Redis Lua脚本）。





还是避免不了NPC 问题：

1. N：Network Delay，网络延迟

2. P：Process Pause，进程暂停（GC）

3. C：Clock Drift，时钟漂移

client A 获取到锁，但是由于上述问题，并没有解锁，然后 锁过期了，那么ClientB也可以获取到锁了。